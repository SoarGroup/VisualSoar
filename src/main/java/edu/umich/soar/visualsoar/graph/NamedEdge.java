package edu.umich.soar.visualsoar.graph;

import edu.umich.soar.visualsoar.datamap.SoarWorkingMemoryModel;
import edu.umich.soar.visualsoar.operatorwindow.OperatorNode;
import edu.umich.soar.visualsoar.parser.Triple;
import edu.umich.soar.visualsoar.parser.TripleUtils;
import edu.umich.soar.visualsoar.util.QueueAsLinkedList;
import edu.umich.soar.visualsoar.util.VSQueue;

import java.util.Enumeration;

/**
 * This represents an attribute in Working Memory
 *
 * @author Brad Jones
 * @version 0.5a Oct 1999
 */

public class NamedEdge extends Edge 
{
///////////////////////////////////////////////////////////////////
// Data Members
///////////////////////////////////////////////////////////////////
    /**
     * The name of this named edge
     */
    protected String name;
         
    /**
     * Comments user attributes to this edge on the datamap
     */
    private String comment = "";

    /**
     * Knowledge of whether generated by DataMap generator.
     * If it is true, will show up as green on the datamap
     * until validated by user.
     */
    private boolean generated;

    /**
     * These are used to hold the information of where in the rules that
     * this NamedEdge was generated during the datamap generation.
     */
    private OperatorNode node = null;
    private int lineNumber = 0;

    /**
     *  Status of NamedEdge as follows:
     *  0 = Never tested or created by project's productions
     *  1 = Tested by a rule  (condition)
     *  2 = Created by a rule (action)
     *  3 = Both tested and created by rules
     */
    private int testedStatus;
    /*  keeps track of if edge was already reported as never tested/created
        so that it doesn't show up multiple times in feedback list
    */
    private boolean errorNoted;
    
///////////////////////////////////////////////////////////////////
// Constructors
///////////////////////////////////////////////////////////////////
    // Deny Default Construction
    /**
     * A named edge is logically a connection between two
     * vertices, from v0 to v1, with a name
     * @param v0 where the edge starts
     * @param v1 where the edge ends
     * @param _name the name that you want to name the string, note
     * if you change this string you also change the name of the node
     */
    public NamedEdge(SoarVertex v0, SoarVertex v1, String _name)
    {
        super(v0,v1);
        name = _name;
        generated = false;
        testedStatus = 0;
        errorNoted = false;
    }
    
///////////////////////////////////////////////////////////////////
// Methods
///////////////////////////////////////////////////////////////////
    /**
     * This method returns the name of the node, note if the return
     * value of this string is changed so is the name of the node
     * @return the name of this node
     */
    public String getName() 
    {
        return name;
    }

    /**
     * This method changes the name of the node from whatever it was
     * to the parameter passed, note changes to s will change the
     * name of the node
     */
    public void rename(String s) 
    {
        name  = s;
    }
    
    /**
     * This presents a String representation of this class
     * it is the name of the edge followed by representation
     * of v1's toString() method
     * @return a string just described
     */
    public String toString() 
    {
        return name + v1.toString();
    }
    
    /**
     * This is the write method that writes out a representation
     * of this edge to the Writer that can later be read back in
     * to recreate this edge
     * @param w the stream to write the representation to
     * @throws java.io.IOException if an error writing to the stream occurs
     */
    public void write(java.io.Writer w) throws java.io.IOException 
    {
        w.write("" + v0.getValue() + ' ' + name + ' ' + v1.getValue() + '\n');
    }
    
    /**
     * an edge is equal to another object if and only if
     * the other object is an edge, not null and the starting
     * ending vertexes are equal and the names are the same
     * @param o the object that you want to test equality
     * @return whether the test was true or false like just described
     */
    public boolean equals(Object o) 
    {
        if (o instanceof NamedEdge)
        {
            NamedEdge anotherEdge = (NamedEdge)o;
            return v0.getValue() == anotherEdge.V0().getValue() &&
                    v1.getValue() == anotherEdge.V1().getValue() &&
                    name.equals(anotherEdge.getName());
        }

        return false;
    }//equals
    
    /**
     * satisfies tests whether this edge could be used to satisfy the
     * constraint passed in, if so, it returns true else false
     *
     * @param triple the constraint to test satisfaction to
     * @return true if this NamedEdge can satisfy that constraint
     */
    public boolean satisfies(Triple triple) 
    {
        if (!TripleUtils.isVariable(triple.getAttribute().getString())) {
            if (!triple.getAttribute().getString().equals(name)) {
                return false;
            }
        }
        if (TripleUtils.isVariable(triple.getValue().getString())) {
            return true;
        }
        SoarVertex sv = V1();
        return sv.isValid(triple.getValue().getString());
    }



    public boolean hasComment() 
    {
        return !comment.equals("");
    }

    public void setComment(String newComment) 
    {
        comment = newComment;
    }

    public String getComment() 
    {
        return comment;
    }

    public boolean isGenerated() 
    {
        return generated;
    }

    /*
     *  Called when the datamap automatically generates the edge on the
     *  datamap.  Displayed as green text on datamap.
     */
    public void setAsGenerated() 
    {
        generated = true;
    }

    /*
     *  When user validates the edge generated by the datamap generator
     *  generated variable goes to false and subsequently the datamap know
     *  displays the edge as normal black color text.
     */
    public void validate() 
    {
        generated = false;
        lineNumber = 0;
        node = null;
    }

    /**
     *  If this edge was already reported as non created/tested, then
     *  it will return true so that the error is not reported multiple times
     */
    public boolean getErrorNoted() 
    {
        return errorNoted;
    }

    /**
     *  Sets the errorNoted variable of this edge as true, meaning that it has already
     *  been reported to the feedback list as non-tested/created
     */
    public void setErrorNoted() 
    {
        errorNoted = true;
    }

    /**
     *  resets the errorNoted variable of this edge, meaning that it
     *  has never been reported by the feedback list as non-tested/created.
     */
    public void resetErrorNoted() 
    {
        errorNoted = false;
    }


    /**
     *  If this edge was created by a production (action side of production)
     *  this will return true.
     */
    public boolean isCreated() 
    {
        return (testedStatus == 2) || (testedStatus == 3);
    }

    /**
     *  Returns true only if edge was created but NEVER tested
     */
    public boolean isCreatedNoTest() 
    {
        return testedStatus == 2;
    }
  
    /**
     *  Returns true only if edge was tested but NEVER created
     */
    public boolean isTestedNoCreate() 
    {
        return testedStatus == 1;
    }

    /**
     *  If this edge was tested by a production (condition side of production)
     *  this will return true.
     */
    public boolean isTested() 
    {
        return (testedStatus == 1) || (testedStatus == 3);
    }

    /**
     *  If this edge was never tested or created by a production
     *  this will return true.
     */
    public boolean notMentioned() 
    {
        return testedStatus == 0;
    }

    /**
     * Sets testedStatus to zero
     */
    public void resetTestedStatus() 
    {
        testedStatus = 0;
    }

    /**
     *  If edge was already created by a production,
     *  sets testedStatus to 3 (both).
     *  Otherwise, sets testedStatus to 1 (tested).
     */
    public void tested() 
    {
        if(testedStatus == 0) 
        {
            testedStatus = 1;
        }
        else if(testedStatus == 2) 
        {
            testedStatus = 3;
        }
    }

    /**
     *  If edge was already tested by a production,
     *  sets testedStatus to 3 (both).
     *  Otherwise, sets testedStatus to 2 (created).
     */
    public void created() 
    {
        if(testedStatus == 0) 
        {
            testedStatus = 2;
        }
        else if(testedStatus == 1) 
        {
            testedStatus = 3;
        }
    }


    /**
     *  Initializes/Sets all edges on the output link as tested.
     */
    public void setOutputLinkTested(SoarWorkingMemoryModel swmm)
    {
        // make sure this is the output-link
        if(!getName().equals("output-link"))  return;
        VSQueue<SoarVertex> queue = new QueueAsLinkedList<>();
        int numberOfVertices = swmm.getNumberOfVertices();
        boolean[] visitedVertices = new boolean[numberOfVertices];
        for(int i = 0; i < numberOfVertices; i++) {
            visitedVertices[i] = false;
        }
        queue.enqueue(this.V1());
        this.tested();
        this.setErrorNoted();

        while(!queue.isEmpty())
        {
            SoarVertex w = queue.dequeue();
            visitedVertices[w.getValue()] = true;
            if(w.allowsEmanatingEdges()) 
            {
                Enumeration<NamedEdge> edges = swmm.emanatingEdges(w);
                while(edges.hasMoreElements()) 
                {
                    NamedEdge theEdge = edges.nextElement();
                    theEdge.tested();
                    theEdge.setErrorNoted();
                    if(! visitedVertices[theEdge.V1().getValue()]) 
                    {
                        visitedVertices[w.getValue()] = true;
                        queue.enqueue(theEdge.V1());
                    }   // if haven't visited this vertex, add to the queue
                } // while looking at all the edges of the vertex
            }
        }   // while queue is not empty, examine each vertex in it

    } // end of setOutputLinkTested()


    public OperatorNode getNode()
    {
        return node;
    }

    public void setNode(OperatorNode newNode) 
    {
        node = newNode;
    }

    public int getLine() 
    {
        return lineNumber;
    }

    public void setLineNumber(int number) 
    {
        lineNumber = number;
    }

}
